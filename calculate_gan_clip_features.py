import os
import os.path as osp
import argparse
import clip
import torch
from torchvision import transforms
from lib import GENFORCE_MODELS
from models.load_generator import load_generator
from tqdm import tqdm


def main():
    """Calculate image features using the CLIP Image Encoder for a set of images generated by the pre-trained GANs
    given in lib/config.py (GENFORCE_MODELS). The features are stored under ./experiments/gan_clip_features/.

    Options:
        -v, --verbose    : set verbose mode on
        --num-samples    : set the number of latent codes to sample for generating images
        --cuda           : use CUDA (default)
        --no-cuda        : do not use CUDA
    """
    parser = argparse.ArgumentParser(description="Calculate CLIP image features for GAN generated images")
    parser.add_argument('-v', '--verbose', action='store_true', help="verbose mode on")
    parser.add_argument('--num-samples', type=int, default=10000, help="set number of latent codes to sample")
    parser.add_argument('--batch-size', type=int, default=16, help="set batch size for image generation")
    parser.add_argument('--cuda', dest='cuda', action='store_true', help="use CUDA during training")
    parser.add_argument('--no-cuda', dest='cuda', action='store_false', help="do NOT use CUDA during training")
    parser.set_defaults(cuda=True)
    # ================================================================================================================ #

    # Parse given arguments
    args = parser.parse_args()

    # Create output directory
    out_dir = osp.join('experiments', 'gan_clip_features')
    os.makedirs(out_dir, exist_ok=True)

    # CUDA
    use_cuda = False
    if torch.cuda.is_available():
        if args.cuda:
            use_cuda = True
            torch.set_default_tensor_type('torch.cuda.FloatTensor')
        else:
            print("*** WARNING ***: It looks like you have a CUDA device, but aren't using CUDA.\n"
                  "                 Run with --cuda for optimal training speed.")
            torch.set_default_tensor_type('torch.FloatTensor')
    else:
        torch.set_default_tensor_type('torch.FloatTensor')

    # Build pretrained CLIP model
    print("#. Build pretrained CLIP model...")
    clip_model, _ = clip.load("ViT-B/32", device='cuda' if use_cuda else 'cpu', jit=False)
    clip_model.float()
    clip_model.eval()

    clip_img_transform = transforms.Compose([transforms.Resize(224),
                                             transforms.CenterCrop(224),
                                             transforms.Normalize((0.48145466, 0.4578275, 0.40821073),
                                                                  (0.26862954, 0.26130258, 0.27577711))])

    gan_cnt = 0
    for gan in GENFORCE_MODELS.keys():
        gan_cnt += 1
        print("#. GAN: {} [{}/{}]".format(gan, gan_cnt, len(GENFORCE_MODELS.keys())))

        ################################################################################################################
        ##                                                                                                            ##
        ##                                               [ StyleGANs ]                                                ##
        ##                                                                                                            ##
        ################################################################################################################
        if 'stylegan' in gan:
            ############################################################################################################
            ##                                         [ StyleGAN @ Z-space ]                                         ##
            ############################################################################################################
            # Build GAN generator model and load with pre-trained weights
            G = load_generator(model_name=gan, latent_is_w=True).eval()

            # Upload GAN generator model to GPU
            if use_cuda:
                G = G.cuda()

            # Latent codes sampling
            zs = torch.randn(args.num_samples, G.dim_z)

            if use_cuda:
                zs = zs.cuda()

            TRUNCATION_VALUES = (0.5, 0.6, 0.7, 0.8, 0.9, 1.0)
            print("  \\__.Use truncation in {}".format(TRUNCATION_VALUES))
            for truncation in TRUNCATION_VALUES:
                # Split latent codes in batches
                zs_batches = torch.split(zs, args.batch_size)
                image_clip_features = []
                for b in tqdm(range(len(zs_batches)),
                              desc="      \\__Generate {} images and get CLIP features [truncation: {}]:".format(
                                  args.num_samples, truncation)):
                    with torch.no_grad():
                        ws_batch = G.get_w(zs_batches[b], truncation=truncation)
                        imgs_batch = G(ws_batch)
                        image_clip_features.append(clip_model.encode_image(clip_img_transform(imgs_batch)))
                image_clip_features = torch.cat(image_clip_features)

                # Save features
                torch.save(image_clip_features,
                           osp.join(out_dir, '{}-W-truncation-{}_img_clip_features_{}.pt'.format(
                               gan, truncation, args.num_samples)))

        ################################################################################################################
        ##                                                                                                            ##
        ##                                           [ ProgGAN @ Z-space]                                             ##
        ##                                                                                                            ##
        ################################################################################################################
        else:
            # Build GAN generator model and load with pre-trained weights
            G = load_generator(model_name=gan, verbose=False).eval()

            # Upload GAN generator model to GPU
            if use_cuda:
                G = G.cuda()

            # Latent codes sampling
            zs = torch.randn(args.num_samples, G.dim_z)

            if use_cuda:
                zs = zs.cuda()

            # Split latent codes in batches
            zs_batches = torch.split(zs, args.batch_size)
            image_clip_features = []
            for b in tqdm(range(len(zs_batches)),
                          desc="  \\__Generate {} images and get CLIP features:".format(args.num_samples)):
                with torch.no_grad():
                    imgs_batch = G(zs_batches[b])
                    image_clip_features.append(clip_model.encode_image(clip_img_transform(imgs_batch)))
            image_clip_features = torch.cat(image_clip_features)

            # Save features
            torch.save(image_clip_features,
                       osp.join(out_dir, '{}_img_clip_features_{}.pt'.format(gan, args.num_samples)))


if __name__ == '__main__':
    main()
